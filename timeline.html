<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dance Timeline Planner</title>
    <style>
        body { background: #1a1a1a; color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        #toolbar { position: fixed; top: 0; left: 0; right: 0; height: 46px; background: #333; display: flex; align-items: center; gap: 15px; padding: 0 15px; border-bottom: 2px solid #444; font-size: 13px; z-index: 100; }
        #toolbar input[type="text"], #toolbar input[type="number"] { background: #222; color: #eee; border: 1px solid #555; padding: 3px 6px; font-size: 12px; }
        #toolbar button { cursor: pointer; padding: 4px 10px; background: #444; color: white; border: 1px solid #666; font-size: 12px; }
        #toolbar button:hover { background: #555; }
        .toolbar-section { display: flex; align-items: center; gap: 8px; }
        .toolbar-divider { width: 1px; height: 28px; background: #555; }
        #time-display { font-family: monospace; font-size: 14px; color: #0f0; min-width: 60px; text-align: center; }

        #library-panel { position: fixed; left: 0; top: 48px; width: 240px; bottom: 0; background: #222; border-right: 1px solid #444; overflow-y: auto; padding: 10px; box-sizing: border-box; z-index: 90; }
        #library-panel h4 { margin: 0 0 10px 0; font-size: 13px; color: #aaa; display: flex; justify-content: space-between; align-items: center; }
        #library-search { width: 100%; background: #111; color: #eee; border: 1px solid #444; padding: 4px 6px; font-size: 11px; margin-bottom: 8px; box-sizing: border-box; }
        .anim-entry { background: #2a2a2a; border: 1px solid #444; border-radius: 4px; padding: 8px; margin-bottom: 6px; cursor: grab; position: relative; }
        .anim-entry:hover { border-color: #666; }
        .anim-entry .anim-name { font-size: 12px; font-weight: bold; color: #eee; }
        .anim-entry .anim-duration { font-size: 10px; color: #888; }
        .anim-entry .anim-bar { height: 8px; border-radius: 3px; margin-top: 4px; position: relative; }
        .anim-entry .anim-marker-dot { position: absolute; top: -1px; width: 4px; height: 10px; background: #fff; border-radius: 2px; }
        .anim-entry .anim-actions { position: absolute; top: 4px; right: 4px; display: none; }
        .anim-entry:hover .anim-actions { display: flex; gap: 3px; }
        .anim-actions button { padding: 2px 5px; font-size: 9px; background: #555; border: none; color: #ccc; cursor: pointer; border-radius: 2px; }
        .anim-actions button:hover { background: #777; }
        #library-buttons { display: flex; gap: 5px; margin-top: 10px; font-size: 11px; }
        #library-buttons button { flex: 1; padding: 5px; font-size: 10px; }

        #canvas-container { position: fixed; left: 240px; top: 48px; right: 0; bottom: 0; overflow: hidden; }
        #timelineCanvas { display: block; }

        /* Dialogs */
        .dialog-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 200; justify-content: center; align-items: center; }
        .dialog-overlay.active { display: flex; }
        .dialog { background: #333; border: 1px solid #555; border-radius: 6px; padding: 20px; min-width: 350px; max-width: 500px; }
        .dialog h3 { margin: 0 0 15px 0; font-size: 14px; color: #ccc; }
        .dialog label { display: block; font-size: 12px; margin-bottom: 10px; color: #aaa; }
        .dialog label span { display: block; margin-bottom: 3px; }
        .dialog input, .dialog select { width: 100%; background: #222; color: #eee; border: 1px solid #555; padding: 5px; font-size: 12px; box-sizing: border-box; }
        .dialog input[type="color"] { width: 50px; height: 30px; padding: 2px; }
        .dialog .dialog-buttons { display: flex; gap: 8px; margin-top: 15px; justify-content: flex-end; }
        .dialog .dialog-buttons button { padding: 6px 16px; font-size: 12px; cursor: pointer; border: 1px solid #666; }
        .dialog .btn-primary { background: #2a6a2a; color: white; }
        .dialog .btn-cancel { background: #444; color: #ccc; }
        .dialog .btn-danger { background: #6a2a2a; color: white; }
        .markers-list { max-height: 120px; overflow-y: auto; margin-top: 5px; }
        .marker-row { display: flex; gap: 5px; align-items: center; margin-bottom: 4px; font-size: 11px; }
        .marker-row input { flex: 1; }
        .marker-row input[type="number"] { width: 50px; flex: none; }
        .marker-row button { padding: 2px 6px; font-size: 10px; background: #633; border: none; color: #ccc; cursor: pointer; }

        /* Context menu */
        #context-menu { display: none; position: fixed; background: #333; border: 1px solid #555; border-radius: 4px; padding: 4px 0; z-index: 300; min-width: 140px; }
        #context-menu.active { display: block; }
        .ctx-item { padding: 6px 16px; font-size: 12px; cursor: pointer; color: #eee; }
        .ctx-item:hover { background: #444; }
        .ctx-divider { height: 1px; background: #444; margin: 3px 0; }

        button { cursor: pointer; }

        /* Animation Sets */
        .set-header { display: flex; align-items: center; gap: 5px; padding: 6px 4px; margin-top: 6px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a; cursor: pointer; user-select: none; }
        .set-header:hover { background: #333; }
        .set-header .set-arrow { font-size: 9px; color: #888; width: 12px; text-align: center; transition: transform 0.15s; }
        .set-header.collapsed .set-arrow { transform: rotate(-90deg); }
        .set-header .set-name { font-size: 11px; font-weight: bold; color: #ccc; flex: 1; }
        .set-header .set-count { font-size: 9px; color: #888; }
        .set-header .set-mirror-rule { font-size: 9px; color: #666; font-style: italic; display: none; }
        .set-header:not(.collapsed) .set-mirror-rule { display: inline; }
        .set-header .set-remove { font-size: 9px; padding: 1px 5px; background: #533; border: 1px solid #644; color: #c99; border-radius: 3px; margin-left: auto; cursor: pointer; line-height: 1; }
        .set-header .set-remove:hover { background: #744; color: #fcc; }
        .set-header:first-child { margin-top: 0; }
        .set-body { overflow: hidden; }
        .set-body.collapsed { display: none; }
        .anim-entry .anim-mirror { font-size: 9px; color: #777; font-style: italic; }
        .mirror-badge { display: inline-block; background: #553; color: #cc8; font-size: 8px; padding: 1px 4px; border-radius: 3px; margin-left: 4px; vertical-align: middle; font-weight: bold; }
        .sets-list-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: #2a2a2a; border: 1px solid #444; border-radius: 3px; margin-bottom: 4px; }
        .sets-list-item .set-item-name { font-weight: bold; font-size: 12px; color: #eee; flex: 1; }
        .sets-list-item .set-item-rule { font-size: 10px; color: #888; flex: 1; }
        .sets-list-item button { padding: 2px 6px; font-size: 10px; background: #444; border: 1px solid #666; color: #ccc; }
    </style>
</head>
<body>

<div id="toolbar">
    <div class="toolbar-section">
        Song: <input type="text" id="songTitle" value="Untitled" style="width: 140px;" oninput="updateSong()">
        Dur: <input type="text" id="songDuration" value="3:00" style="width: 50px;" onchange="updateSong()">
        BPM: <input type="number" id="songBPM" value="0" min="0" max="300" style="width: 45px;" onchange="updateSong()">
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button onclick="stopPlayback()" title="Stop">&#9632;</button>
        <button onclick="togglePlayback()" id="playBtn" title="Play/Pause">&#9654;</button>
        <span id="time-display">0:00.0</span>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button onclick="zoomIn()">Zoom +</button>
        <button onclick="zoomOut()">Zoom -</button>
        <label style="font-size: 11px;"><input type="checkbox" id="snapToggle" onchange="renderTimeline()"> Snap</label>
    </div>
    <div class="toolbar-divider"></div>
    <div class="toolbar-section">
        <button onclick="exportProject()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display:none;" onchange="importProject(event)">
        <button onclick="newProject()" style="background: #633;">New</button>
    </div>
</div>

<div id="library-panel">
    <h4>Animation Library
        <span style="display: flex; gap: 3px;">
            <button onclick="showSetsDialog()" style="padding: 2px 8px; font-size: 11px; background: #444; border: 1px solid #666; color: #ccc;">Sets</button>
            <button onclick="showAddAnimDialog()" style="padding: 2px 8px; font-size: 11px; background: #2a6a2a; border: 1px solid #4a4; color: #cfc;">+ Add</button>
        </span>
    </h4>
    <input type="text" id="library-search" placeholder="Search animations..." oninput="buildLibraryUI()">
    <div id="library-list"></div>
    <div id="library-buttons">
        <button onclick="exportLibrary()">Export Lib</button>
        <button onclick="document.getElementById('importLibFile').click()">Import Lib</button>
        <input type="file" id="importLibFile" accept=".json" style="display:none;" onchange="importLibrary(event)">
        <button onclick="document.getElementById('importCsvFile').click()">Import CSV</button>
        <input type="file" id="importCsvFile" accept=".csv,.txt" style="display:none;" onchange="importCSV(event)">
    </div>
</div>

<div id="canvas-container">
    <canvas id="timelineCanvas"></canvas>
</div>

<img src="ChoreoToolLogo.png" alt="Logo" style="position: fixed; left: 10px; bottom: 10px; z-index: 95; opacity: 0.7;">

<!-- Animation Sets Dialog -->
<div id="setsDialog" class="dialog-overlay">
    <div class="dialog" style="min-width: 420px;">
        <h3>Animation Sets</h3>
        <p style="font-size: 11px; color: #888; margin: 0 0 12px 0;">Each set defines how mirrored animation names are built. Use <code style="background: #222; padding: 1px 4px;">{name}</code> as placeholder for the original name.</p>
        <div id="sets-list" style="max-height: 250px; overflow-y: auto; margin-bottom: 12px;"></div>
        <div style="display: flex; gap: 8px; align-items: center; border-top: 1px solid #444; padding-top: 10px;">
            <input type="text" id="newSetName" placeholder="Set name" style="flex: 1; background: #222; color: #eee; border: 1px solid #555; padding: 5px; font-size: 12px;">
            <input type="text" id="newSetRule" placeholder="{name}_mirror" value="{name}_mirror" style="flex: 1; background: #222; color: #eee; border: 1px solid #555; padding: 5px; font-size: 12px;">
            <button onclick="addSet()" class="btn-primary" style="padding: 5px 12px; font-size: 12px;">Add</button>
        </div>
        <div class="dialog-buttons">
            <button class="btn-cancel" onclick="closeSetsDialog()">Close</button>
        </div>
    </div>
</div>

<!-- Add/Edit Animation Dialog -->
<div id="animDialog" class="dialog-overlay">
    <div class="dialog">
        <h3 id="animDialogTitle">Add Animation</h3>
        <input type="hidden" id="animDialogId">
        <label><span>Animation Name (SL name)</span><input type="text" id="animName" placeholder="e.g. dance_slow_waltz" oninput="updateMirrorPreview()"></label>
        <label><span>Animation Set</span><select id="animSet" onchange="updateMirrorPreview()" style="width: 100%; background: #222; color: #eee; border: 1px solid #555; padding: 5px; font-size: 12px;"><option value="">(none)</option></select></label>
        <div id="mirrorPreview" style="font-size: 10px; color: #888; margin: -6px 0 8px 0; font-style: italic;"></div>
        <label><span>Duration (seconds)</span><input type="number" id="animDuration" value="8" min="0.1" step="0.1"></label>
        <label><span>Color</span><input type="color" id="animColor" value="#4488FF"></label>
        <label><span>Key Moments</span>
            <div id="animMarkers" class="markers-list"></div>
            <button onclick="addAnimMarkerRow()" style="font-size: 10px; padding: 3px 8px; margin-top: 4px; background: #444; border: 1px solid #666; color: #ccc;">+ Add Marker</button>
        </label>
        <div class="dialog-buttons">
            <button class="btn-cancel" onclick="closeAnimDialog()">Cancel</button>
            <button class="btn-primary" onclick="saveAnimation()">Save</button>
        </div>
    </div>
</div>

<!-- Add/Edit Marker Dialog -->
<div id="markerDialog" class="dialog-overlay">
    <div class="dialog">
        <h3 id="markerDialogTitle">Add Section Marker</h3>
        <input type="hidden" id="markerDialogId">
        <label><span>Label</span><input type="text" id="markerLabel" placeholder="e.g. Chorus"></label>
        <label><span>Time (seconds)</span><input type="number" id="markerTime" value="0" min="0" step="0.1"></label>
        <label><span>Color</span><input type="color" id="markerColor" value="#FF6644"></label>
        <div class="dialog-buttons">
            <button class="btn-cancel" onclick="closeMarkerDialog()">Cancel</button>
            <button class="btn-primary" onclick="saveMarker()">Save</button>
        </div>
    </div>
</div>

<!-- Add/Edit Lyric Dialog -->
<div id="lyricDialog" class="dialog-overlay">
    <div class="dialog">
        <h3 id="lyricDialogTitle">Add Lyric</h3>
        <input type="hidden" id="lyricDialogId">
        <label><span>Text</span><input type="text" id="lyricText" placeholder="Lyrics..."></label>
        <label><span>Time (seconds)</span><input type="number" id="lyricTime" value="0" min="0" step="0.1"></label>
        <div class="dialog-buttons">
            <button class="btn-cancel" onclick="closeLyricDialog()">Cancel</button>
            <button class="btn-primary" onclick="saveLyric()">Save</button>
        </div>
    </div>
</div>

<!-- Context Menu -->
<div id="context-menu"></div>

<script>
    // ===== CONSTANTS =====
    const RULER_HEIGHT = 30;
    const MARKER_TRACK_HEIGHT = 26;
    const LYRICS_TRACK_HEIGHT = 24;
    const GROUP_TRACK_HEIGHT = 48;
    const TRACK_GAP = 2;
    const HEADER_WIDTH = 90;
    const BASE_PPS = 40; // base pixels per second
    const STORAGE_KEY = 'choreoTimelineProject';
    const EDGE_GRAB_PX = 6;

    const canvas = document.getElementById('timelineCanvas');
    const ctx = canvas.getContext('2d');

    // ===== STATE =====
    let project = null;
    let scrollX = 0;
    let playback = { playing: false, cursorTime: 0, startTs: null };
    let interaction = { dragging: null, hovering: null, selectedBlock: null, selectedGroup: null };
    let dragFromLibrary = null; // { animId, ghostX, ghostY, ghostTrack }
    let lastMouseX = 0, lastMouseY = 0;
    let collapsedSets = new Set(); // track collapsed set IDs in library panel

    // ===== DATA =====
    function generateId(prefix) { return prefix + '_' + Date.now() + '_' + Math.floor(Math.random() * 1000); }

    function createDefaultProject() {
        return {
            version: 2,
            song: { title: 'Untitled', duration: 180, bpm: 0, bpmOffset: 0 },
            animationSets: [],
            animationLibrary: [
                { id: generateId('anim'), name: 'dance_slow', duration: 8.0, color: '#4488FF', markers: [{ time: 4.0, label: 'Turn' }], setId: '' },
                { id: generateId('anim'), name: 'dance_fast', duration: 4.0, color: '#FF4488', markers: [], setId: '' },
                { id: generateId('anim'), name: 'pose_hold', duration: 6.0, color: '#44FF88', markers: [{ time: 3.0, label: 'Shift' }], setId: '' }
            ],
            markers: [
                { id: generateId('mkr'), time: 0, label: 'Intro', color: '#FF6644' },
                { id: generateId('mkr'), time: 30, label: 'Verse 1', color: '#44AA44' },
                { id: generateId('mkr'), time: 60, label: 'Chorus', color: '#4488FF' }
            ],
            lyrics: [
                { id: generateId('lyr'), time: 5, text: 'When the music starts...' },
                { id: generateId('lyr'), time: 35, text: 'Dancing through the night...' }
            ],
            groups: [
                { id: 'grp_1', name: 'Group 1', groupIndex: 1, color: '#00FF00', blocks: [] },
                { id: 'grp_2', name: 'Group 2', groupIndex: 2, color: '#8B00FF', blocks: [] }
            ],
            viewState: { scrollX: 0, zoom: 1.0, snapToGrid: false }
        };
    }

    // ===== COORDINATE HELPERS =====
    function getPPS() { return BASE_PPS * project.viewState.zoom; }
    function timeToX(t) { return HEADER_WIDTH + (t * getPPS()) - scrollX; }
    function xToTime(px) { return (px - HEADER_WIDTH + scrollX) / getPPS(); }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function getTrackY(type, index) {
        let y = RULER_HEIGHT;
        if (type === 'markers') return y;
        y += MARKER_TRACK_HEIGHT + TRACK_GAP;
        if (type === 'lyrics') return y;
        y += LYRICS_TRACK_HEIGHT + TRACK_GAP;
        if (type === 'group') return y + index * (GROUP_TRACK_HEIGHT + TRACK_GAP);
        return y;
    }

    function getTrackAtY(py) {
        let y = RULER_HEIGHT;
        if (py < y) return { type: 'ruler', index: -1 };
        if (py < y + MARKER_TRACK_HEIGHT) return { type: 'markers', index: -1 };
        y += MARKER_TRACK_HEIGHT + TRACK_GAP;
        if (py < y + LYRICS_TRACK_HEIGHT) return { type: 'lyrics', index: -1 };
        y += LYRICS_TRACK_HEIGHT + TRACK_GAP;
        for (let i = 0; i < project.groups.length; i++) {
            if (py < y + GROUP_TRACK_HEIGHT) return { type: 'group', index: i };
            y += GROUP_TRACK_HEIGHT + TRACK_GAP;
        }
        return { type: 'empty', index: -1 };
    }

    function snapTime(t) {
        if (!project.viewState.snapToGrid || !project.song.bpm || project.song.bpm <= 0) return t;
        const beatDur = 60.0 / project.song.bpm;
        const off = project.song.bpmOffset || 0;
        return off + Math.round((t - off) / beatDur) * beatDur;
    }

    // ===== RENDERING =====
    function renderTimeline() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);

        drawTimeRuler();
        drawBeatGrid();
        drawMarkersTrack();
        drawLyricsTrack();
        drawGroupTracks();
        drawPlaybackCursor();
        drawDragPreview();
        drawTrackHeaders();
    }

    function drawTimeRuler() {
        const y = 0;
        ctx.fillStyle = '#252525';
        ctx.fillRect(0, y, canvas.width, RULER_HEIGHT);

        const pps = getPPS();
        const startTime = Math.max(0, xToTime(HEADER_WIDTH));
        const endTime = xToTime(canvas.width);

        // Determine tick intervals based on zoom
        let majorInterval = 10;
        let minorInterval = 1;
        if (pps < 10) { majorInterval = 60; minorInterval = 10; }
        else if (pps < 25) { majorInterval = 30; minorInterval = 5; }
        else if (pps > 100) { majorInterval = 5; minorInterval = 1; }
        else if (pps > 200) { majorInterval = 1; minorInterval = 0.5; }

        // Minor ticks
        ctx.strokeStyle = '#333';
        const minStart = Math.floor(startTime / minorInterval) * minorInterval;
        for (let t = minStart; t <= endTime; t += minorInterval) {
            const x = timeToX(t);
            if (x < HEADER_WIDTH) continue;
            ctx.beginPath();
            ctx.moveTo(x, RULER_HEIGHT - 6);
            ctx.lineTo(x, RULER_HEIGHT);
            ctx.stroke();
        }

        // Major ticks + labels
        ctx.strokeStyle = '#555';
        ctx.fillStyle = '#999';
        ctx.font = '10px Segoe UI';
        ctx.textAlign = 'center';
        const majStart = Math.floor(startTime / majorInterval) * majorInterval;
        for (let t = majStart; t <= endTime; t += majorInterval) {
            const x = timeToX(t);
            if (x < HEADER_WIDTH) continue;
            ctx.beginPath();
            ctx.moveTo(x, RULER_HEIGHT - 14);
            ctx.lineTo(x, RULER_HEIGHT);
            ctx.stroke();
            ctx.fillText(formatTime(t), x, RULER_HEIGHT - 16);
        }

        // Bottom border
        ctx.strokeStyle = '#444';
        ctx.beginPath();
        ctx.moveTo(0, RULER_HEIGHT);
        ctx.lineTo(canvas.width, RULER_HEIGHT);
        ctx.stroke();
    }

    function drawBeatGrid() {
        if (!project.song.bpm || project.song.bpm <= 0) return;
        const beatDur = 60.0 / project.song.bpm;
        const off = project.song.bpmOffset || 0;
        const startTime = Math.max(0, xToTime(HEADER_WIDTH));
        const endTime = xToTime(canvas.width);
        const startBeat = Math.floor((startTime - off) / beatDur);
        const endBeat = Math.ceil((endTime - off) / beatDur);

        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        for (let b = startBeat; b <= endBeat; b++) {
            const t = off + b * beatDur;
            if (t < 0) continue;
            const x = timeToX(t);
            if (x < HEADER_WIDTH) continue;
            ctx.globalAlpha = (b % 4 === 0) ? 0.5 : 0.2;
            ctx.beginPath();
            ctx.moveTo(x, RULER_HEIGHT);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        ctx.lineWidth = 1;
    }

    function drawMarkersTrack() {
        const y = getTrackY('markers');
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(0, y, canvas.width, MARKER_TRACK_HEIGHT);

        const sorted = [...project.markers].sort((a, b) => a.time - b.time);
        for (let i = 0; i < sorted.length; i++) {
            const m = sorted[i];
            const x = timeToX(m.time);
            const nextX = (i + 1 < sorted.length) ? timeToX(sorted[i + 1].time) : timeToX(project.song.duration);
            if (nextX < HEADER_WIDTH || x > canvas.width) continue;

            const drawX = Math.max(HEADER_WIDTH, x);
            const drawW = Math.min(canvas.width, nextX) - drawX;

            ctx.fillStyle = hexToRgba(m.color, 0.2);
            ctx.fillRect(drawX, y, drawW, MARKER_TRACK_HEIGHT);

            // Label
            ctx.fillStyle = m.color;
            ctx.font = 'bold 10px Segoe UI';
            ctx.textAlign = 'left';
            const labelX = Math.max(drawX + 4, HEADER_WIDTH + 4);
            ctx.fillText(m.label, labelX, y + 16);

            // Tick line
            if (x >= HEADER_WIDTH) {
                ctx.strokeStyle = m.color;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + MARKER_TRACK_HEIGHT);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
        }
    }

    function drawLyricsTrack() {
        const y = getTrackY('lyrics');
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, y, canvas.width, LYRICS_TRACK_HEIGHT);

        ctx.font = '10px Segoe UI';
        ctx.fillStyle = '#bbb';
        ctx.textAlign = 'left';
        for (const l of project.lyrics) {
            const x = timeToX(l.time);
            if (x > canvas.width || x < HEADER_WIDTH - 100) continue;
            const drawX = Math.max(x, HEADER_WIDTH + 2);
            ctx.fillText(l.text, drawX, y + 16);
        }
    }

    function drawGroupTracks() {
        for (let gi = 0; gi < project.groups.length; gi++) {
            const group = project.groups[gi];
            const y = getTrackY('group', gi);

            // Track background
            ctx.fillStyle = (gi % 2 === 0) ? '#1a1a1a' : '#1e1e1e';
            ctx.fillRect(HEADER_WIDTH, y, canvas.width - HEADER_WIDTH, GROUP_TRACK_HEIGHT);

            // Blocks
            for (const block of group.blocks) {
                const anim = project.animationLibrary.find(a => a.id === block.animationId);
                if (!anim) continue;
                drawAnimationBlock(block, anim, y, group);
            }

            // Track separator
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(0, y + GROUP_TRACK_HEIGHT);
            ctx.lineTo(canvas.width, y + GROUP_TRACK_HEIGHT);
            ctx.stroke();
        }
    }

    function drawAnimationBlock(block, anim, trackY, group) {
        const x = timeToX(block.startTime);
        const w = block.duration * getPPS();
        const bx = Math.max(x, HEADER_WIDTH);
        const bw = Math.min(x + w, canvas.width) - bx;
        if (bw <= 0) return;

        const isSelected = (interaction.selectedBlock === block.id);
        const h = GROUP_TRACK_HEIGHT - 6;
        const by = trackY + 3;
        const r = 4;

        // Block body
        ctx.fillStyle = isSelected ? lightenColor(anim.color, 30) : anim.color;
        ctx.globalAlpha = 0.8;
        drawRoundedRect(ctx, bx, by, bw, h, r);
        ctx.fill();

        // Border
        ctx.strokeStyle = isSelected ? '#fff' : lightenColor(anim.color, 40);
        ctx.lineWidth = isSelected ? 2 : 1;
        drawRoundedRect(ctx, bx, by, bw, h, r);
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 1.0;

        // Animation markers inside block
        if (anim.markers && anim.markers.length > 0 && w > 20) {
            const scale = block.duration / anim.duration;
            for (const mk of anim.markers) {
                const mx = x + (mk.time * scale * getPPS());
                if (mx < HEADER_WIDTH || mx > canvas.width) continue;
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(mx, by);
                ctx.lineTo(mx - 3, by - 3);
                ctx.lineTo(mx + 3, by - 3);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Text label
        if (bw > 30) {
            ctx.fillStyle = '#fff';
            ctx.font = '10px Segoe UI';
            ctx.textAlign = 'left';
            ctx.save();
            ctx.beginPath();
            ctx.rect(bx + 4, by, bw - 8, h);
            ctx.clip();

            let displayName = block.label || anim.name;
            if (block.mirrored) {
                const mirrorName = getMirrorName(anim);
                if (mirrorName) displayName = mirrorName;
            }
            ctx.fillText(displayName, bx + 5, by + h / 2 + 3);

            // Mirror badge
            if (block.mirrored) {
                const textW = ctx.measureText(displayName).width;
                ctx.fillStyle = '#cc8';
                ctx.font = 'bold 8px Segoe UI';
                ctx.fillText('M', bx + 8 + textW, by + h / 2 + 3);
            }
            ctx.restore();
        }
    }

    function drawPlaybackCursor() {
        const x = timeToX(playback.cursorTime);
        if (x < HEADER_WIDTH || x > canvas.width) return;

        ctx.strokeStyle = '#FF4444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        ctx.lineWidth = 1;

        // Triangle at top
        ctx.fillStyle = '#FF4444';
        ctx.beginPath();
        ctx.moveTo(x - 5, 0);
        ctx.lineTo(x + 5, 0);
        ctx.lineTo(x, 8);
        ctx.closePath();
        ctx.fill();
    }

    function drawDragPreview() {
        if (!dragFromLibrary || dragFromLibrary.ghostTrack < 0) return;
        const anim = project.animationLibrary.find(a => a.id === dragFromLibrary.animId);
        if (!anim) return;

        const y = getTrackY('group', dragFromLibrary.ghostTrack) + 3;
        const x = timeToX(dragFromLibrary.ghostTime);
        const w = anim.duration * getPPS();
        const h = GROUP_TRACK_HEIGHT - 6;

        ctx.globalAlpha = 0.4;
        ctx.fillStyle = anim.color;
        drawRoundedRect(ctx, x, y, w, h, 4);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        drawRoundedRect(ctx, x, y, w, h, 4);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    function drawTrackHeaders() {
        // Solid background behind headers
        ctx.fillStyle = '#222';
        ctx.fillRect(0, RULER_HEIGHT, HEADER_WIDTH, canvas.height - RULER_HEIGHT);

        ctx.font = '10px Segoe UI';
        ctx.textAlign = 'left';

        // Markers header
        ctx.fillStyle = '#888';
        ctx.fillText('Markers', 8, getTrackY('markers') + 16);

        // Lyrics header
        ctx.fillStyle = '#888';
        ctx.fillText('Lyrics', 8, getTrackY('lyrics') + 16);

        // Group headers
        for (let i = 0; i < project.groups.length; i++) {
            const g = project.groups[i];
            const y = getTrackY('group', i);
            ctx.fillStyle = g.color;
            ctx.beginPath();
            ctx.arc(12, y + GROUP_TRACK_HEIGHT / 2, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ccc';
            ctx.fillText(g.name, 22, y + GROUP_TRACK_HEIGHT / 2 + 3);
        }

        // Separator line
        ctx.strokeStyle = '#444';
        ctx.beginPath();
        ctx.moveTo(HEADER_WIDTH, RULER_HEIGHT);
        ctx.lineTo(HEADER_WIDTH, canvas.height);
        ctx.stroke();
    }

    // ===== DRAWING HELPERS =====
    function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.arcTo(x + w, y, x + w, y + r, r);
        ctx.lineTo(x + w, y + h - r);
        ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
        ctx.lineTo(x + r, y + h);
        ctx.arcTo(x, y + h, x, y + h - r, r);
        ctx.lineTo(x, y + r);
        ctx.arcTo(x, y, x + r, y, r);
        ctx.closePath();
    }

    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function lightenColor(hex, amt) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        r = Math.min(255, r + amt); g = Math.min(255, g + amt); b = Math.min(255, b + amt);
        return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
    }

    function formatTime(s) {
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return m + ':' + sec.toFixed(sec === Math.floor(sec) ? 0 : 1).padStart(sec < 10 ? 4 : 3, '0');
    }

    function parseTime(str) {
        str = str.trim();
        if (str.includes(':')) {
            const parts = str.split(':');
            return parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
        }
        return parseFloat(str) || 0;
    }

    // ===== HIT TESTING =====
    function hitTestBlocks(px, py) {
        const track = getTrackAtY(py);
        if (track.type !== 'group' || track.index < 0) return null;
        const group = project.groups[track.index];
        const y = getTrackY('group', track.index);

        for (const block of group.blocks) {
            const anim = project.animationLibrary.find(a => a.id === block.animationId);
            if (!anim) continue;
            const bx = timeToX(block.startTime);
            const bw = block.duration * getPPS();
            const by = y + 3;
            const bh = GROUP_TRACK_HEIGHT - 6;

            if (px >= bx && px <= bx + bw && py >= by && py <= by + bh) {
                let edge = 'body';
                if (px - bx < EDGE_GRAB_PX) edge = 'left';
                else if (bx + bw - px < EDGE_GRAB_PX) edge = 'right';
                return { blockId: block.id, groupId: group.id, groupIndex: track.index, edge, block, bx, bw };
            }
        }
        return null;
    }

    // ===== CANVAS EVENTS =====
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        hideContextMenu();

        const track = getTrackAtY(py);

        // Click on ruler = seek
        if (track.type === 'ruler' && px >= HEADER_WIDTH) {
            playback.cursorTime = clamp(xToTime(px), 0, project.song.duration);
            if (playback.playing) {
                playback.startTs = performance.now() - playback.cursorTime * 1000;
            }
            updateTimeDisplay();
            renderTimeline();
            return;
        }

        // Click on block
        const hit = hitTestBlocks(px, py);
        if (hit) {
            interaction.selectedBlock = hit.blockId;
            interaction.selectedGroup = hit.groupId;
            if (hit.edge === 'body') {
                interaction.dragging = { type: 'block', blockId: hit.blockId, groupId: hit.groupId, groupIndex: hit.groupIndex, offsetX: px - hit.bx, origStart: hit.block.startTime };
            } else if (hit.edge === 'left') {
                interaction.dragging = { type: 'edge-left', blockId: hit.blockId, groupId: hit.groupId, origStart: hit.block.startTime, origDur: hit.block.duration };
            } else if (hit.edge === 'right') {
                interaction.dragging = { type: 'edge-right', blockId: hit.blockId, groupId: hit.groupId, origDur: hit.block.duration, origStart: hit.block.startTime };
            }
            renderTimeline();
            return;
        }

        // Click empty = deselect
        interaction.selectedBlock = null;
        interaction.selectedGroup = null;
        renderTimeline();
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        lastMouseX = px;
        lastMouseY = py;

        if (interaction.dragging) {
            const d = interaction.dragging;
            if (d.type === 'block') {
                const group = project.groups.find(g => g.id === d.groupId);
                const block = group ? group.blocks.find(b => b.id === d.blockId) : null;
                if (block) {
                    let t = xToTime(px - d.offsetX);
                    t = snapTime(t);
                    block.startTime = Math.max(0, t);
                    renderTimeline();
                }
            } else if (d.type === 'edge-left') {
                const group = project.groups.find(g => g.id === d.groupId);
                const block = group ? group.blocks.find(b => b.id === d.blockId) : null;
                if (block) {
                    let newStart = snapTime(xToTime(px));
                    newStart = Math.max(0, Math.min(newStart, d.origStart + d.origDur - 0.5));
                    const diff = newStart - d.origStart;
                    block.startTime = newStart;
                    block.duration = d.origDur - diff;
                    renderTimeline();
                }
            } else if (d.type === 'edge-right') {
                const group = project.groups.find(g => g.id === d.groupId);
                const block = group ? group.blocks.find(b => b.id === d.blockId) : null;
                if (block) {
                    let endTime = snapTime(xToTime(px));
                    endTime = Math.max(d.origStart + 0.5, endTime);
                    block.duration = endTime - block.startTime;
                    renderTimeline();
                }
            }
            return;
        }

        // Hover cursor
        const hit = hitTestBlocks(px, py);
        if (hit) {
            if (hit.edge === 'left' || hit.edge === 'right') canvas.style.cursor = 'ew-resize';
            else canvas.style.cursor = 'grab';
        } else {
            const track = getTrackAtY(py);
            canvas.style.cursor = (track.type === 'ruler' && px >= HEADER_WIDTH) ? 'pointer' : 'default';
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (interaction.dragging) {
            interaction.dragging = null;
            autoSave();
        }
    });

    canvas.addEventListener('dblclick', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const track = getTrackAtY(py);
        const t = clamp(xToTime(px), 0, project.song.duration);

        if (track.type === 'markers' && px >= HEADER_WIDTH) {
            showMarkerDialog(null, t);
        } else if (track.type === 'lyrics' && px >= HEADER_WIDTH) {
            showLyricDialog(null, t);
        } else if (track.type === 'group') {
            const hit = hitTestBlocks(px, py);
            if (hit) {
                // Double-click block = edit label
                const group = project.groups.find(g => g.id === hit.groupId);
                const block = group ? group.blocks.find(b => b.id === hit.blockId) : null;
                if (block) {
                    const newLabel = prompt('Block label (empty for animation name):', block.label || '');
                    if (newLabel !== null) {
                        block.label = newLabel;
                        autoSave();
                        renderTimeline();
                    }
                }
            }
        }
    });

    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const track = getTrackAtY(py);
        const t = clamp(xToTime(px), 0, project.song.duration);

        const items = [];

        if (track.type === 'markers') {
            items.push({ label: 'Add Marker here', action: () => showMarkerDialog(null, t) });
            // Check if clicking on existing marker
            const sorted = [...project.markers].sort((a, b) => a.time - b.time);
            for (let i = 0; i < sorted.length; i++) {
                const m = sorted[i];
                const mx = timeToX(m.time);
                const nextMx = (i + 1 < sorted.length) ? timeToX(sorted[i + 1].time) : timeToX(project.song.duration);
                if (px >= mx && px < nextMx) {
                    items.push({ label: 'Edit "' + m.label + '"', action: () => showMarkerDialog(m.id) });
                    items.push({ label: 'Delete "' + m.label + '"', action: () => { project.markers = project.markers.filter(x => x.id !== m.id); autoSave(); renderTimeline(); } });
                    break;
                }
            }
        } else if (track.type === 'lyrics') {
            items.push({ label: 'Add Lyric here', action: () => showLyricDialog(null, t) });
            for (const l of project.lyrics) {
                const lx = timeToX(l.time);
                if (px >= lx && px < lx + 150) {
                    items.push({ label: 'Edit lyric', action: () => showLyricDialog(l.id) });
                    items.push({ label: 'Delete lyric', action: () => { project.lyrics = project.lyrics.filter(x => x.id !== l.id); autoSave(); renderTimeline(); } });
                    break;
                }
            }
        } else if (track.type === 'group') {
            const hit = hitTestBlocks(px, py);
            if (hit) {
                const grp = project.groups.find(g => g.id === hit.groupId);
                const blk = grp ? grp.blocks.find(b => b.id === hit.blockId) : null;
                if (blk) {
                    const anim = project.animationLibrary.find(a => a.id === blk.animationId);
                    const hasMirror = anim && getMirrorName(anim);
                    if (hasMirror) {
                        items.push({ label: blk.mirrored ? 'Use Original' : 'Use Mirror', action: () => {
                            blk.mirrored = !blk.mirrored;
                            autoSave(); renderTimeline();
                        }});
                    }
                }
                items.push({ label: 'Delete block', action: () => { deleteBlock(hit.blockId, hit.groupId); } });
            }
            items.push({ label: 'Rename track', action: () => {
                const g = project.groups[track.index];
                const n = prompt('Track name:', g.name);
                if (n !== null) { g.name = n; autoSave(); renderTimeline(); }
            }});
            items.push({ label: 'Remove track', action: () => {
                if (confirm('Remove ' + project.groups[track.index].name + '?')) {
                    project.groups.splice(track.index, 1);
                    autoSave(); renderTimeline();
                }
            }});
        } else if (track.type === 'empty') {
            items.push({ label: 'Add Group Track', action: () => addGroupTrack() });
        }

        if (items.length > 0) showContextMenu(e.clientX, e.clientY, items);
    });

    // Scroll and zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.ctrlKey) {
            const factor = e.deltaY > 0 ? 0.85 : 1.18;
            const cursorTime = xToTime(lastMouseX);
            project.viewState.zoom = clamp(project.viewState.zoom * factor, 0.1, 20.0);
            scrollX = (cursorTime * getPPS()) - (lastMouseX - HEADER_WIDTH);
            scrollX = Math.max(0, scrollX);
        } else {
            scrollX += (e.deltaY || e.deltaX);
            scrollX = Math.max(0, scrollX);
        }
        project.viewState.scrollX = scrollX;
        renderTimeline();
    }, { passive: false });

    // ===== DRAG AND DROP from Library =====
    canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        if (!dragFromLibrary) return;
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const track = getTrackAtY(py);
        dragFromLibrary.ghostTrack = (track.type === 'group') ? track.index : -1;
        dragFromLibrary.ghostTime = snapTime(Math.max(0, xToTime(px)));
        renderTimeline();
    });

    canvas.addEventListener('dragleave', () => {
        if (dragFromLibrary) { dragFromLibrary.ghostTrack = -1; renderTimeline(); }
    });

    canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        if (!dragFromLibrary || dragFromLibrary.ghostTrack < 0) { dragFromLibrary = null; return; }
        const anim = project.animationLibrary.find(a => a.id === dragFromLibrary.animId);
        if (!anim) { dragFromLibrary = null; return; }

        const group = project.groups[dragFromLibrary.ghostTrack];
        group.blocks.push({
            id: generateId('blk'),
            animationId: anim.id,
            startTime: dragFromLibrary.ghostTime,
            duration: anim.duration,
            label: '',
            mirrored: false
        });

        dragFromLibrary = null;
        autoSave();
        renderTimeline();
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
        // Don't handle keys if a dialog is open or input is focused
        if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
        if (document.querySelector('.dialog-overlay.active')) return;

        if (e.code === 'Space') {
            e.preventDefault();
            togglePlayback();
        } else if (e.code === 'Delete' || e.code === 'Backspace') {
            if (interaction.selectedBlock && interaction.selectedGroup) {
                deleteBlock(interaction.selectedBlock, interaction.selectedGroup);
            }
        }
    });

    // ===== BLOCK MANIPULATION =====
    function deleteBlock(blockId, groupId) {
        const group = project.groups.find(g => g.id === groupId);
        if (group) {
            group.blocks = group.blocks.filter(b => b.id !== blockId);
            if (interaction.selectedBlock === blockId) {
                interaction.selectedBlock = null;
                interaction.selectedGroup = null;
            }
            autoSave();
            renderTimeline();
        }
    }

    function addGroupTrack() {
        const nextIdx = project.groups.length + 1;
        const colors = ['#00FF00', '#8B00FF', '#0000FF', '#FFFF00', '#FFA500', '#FF0000', '#00FFFF', '#FF69B4'];
        project.groups.push({
            id: generateId('grp'),
            name: 'Group ' + nextIdx,
            groupIndex: nextIdx,
            color: colors[(nextIdx - 1) % colors.length],
            blocks: []
        });
        autoSave();
        renderTimeline();
    }

    // ===== TRANSPORT =====
    function togglePlayback() {
        if (playback.playing) pausePlayback();
        else startPlayback();
    }

    function startPlayback() {
        playback.playing = true;
        playback.startTs = performance.now() - playback.cursorTime * 1000;
        document.getElementById('playBtn').textContent = '\u275A\u275A';
        requestAnimationFrame(playbackTick);
    }

    function pausePlayback() {
        playback.playing = false;
        document.getElementById('playBtn').textContent = '\u25B6';
    }

    function stopPlayback() {
        playback.playing = false;
        playback.cursorTime = 0;
        document.getElementById('playBtn').textContent = '\u25B6';
        updateTimeDisplay();
        renderTimeline();
    }

    function playbackTick(ts) {
        if (!playback.playing) return;
        playback.cursorTime = (ts - playback.startTs) / 1000;
        if (playback.cursorTime >= project.song.duration) {
            playback.cursorTime = project.song.duration;
            pausePlayback();
        }
        autoScrollToTime(playback.cursorTime);
        updateTimeDisplay();
        renderTimeline();
        if (playback.playing) requestAnimationFrame(playbackTick);
    }

    function autoScrollToTime(t) {
        const x = timeToX(t);
        const margin = 100;
        if (x > canvas.width - margin) {
            scrollX += (x - (canvas.width - margin));
        } else if (x < HEADER_WIDTH + margin && scrollX > 0) {
            scrollX = Math.max(0, scrollX - (HEADER_WIDTH + margin - x));
        }
    }

    function updateTimeDisplay() {
        document.getElementById('time-display').textContent = formatTime(playback.cursorTime);
    }

    // ===== ZOOM =====
    function zoomIn() { project.viewState.zoom = clamp(project.viewState.zoom * 1.3, 0.1, 20); renderTimeline(); }
    function zoomOut() { project.viewState.zoom = clamp(project.viewState.zoom / 1.3, 0.1, 20); renderTimeline(); }

    // ===== SONG SETUP =====
    function updateSong() {
        project.song.title = document.getElementById('songTitle').value;
        project.song.duration = parseTime(document.getElementById('songDuration').value);
        project.song.bpm = parseInt(document.getElementById('songBPM').value) || 0;
        autoSave();
        renderTimeline();
    }

    // ===== ANIMATION LIBRARY =====
    function buildLibraryUI() {
        const search = document.getElementById('library-search').value.toLowerCase();
        const container = document.getElementById('library-list');
        container.innerHTML = '';

        const filtered = project.animationLibrary.filter(a => a.name.toLowerCase().includes(search));

        // Group by set
        const groups = new Map(); // setId â†’ anims
        for (const anim of filtered) {
            const key = anim.setId || '';
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(anim);
        }

        // Render sets first, then ungrouped
        const setOrder = [...project.animationSets.map(s => s.id), ''];
        for (const setId of setOrder) {
            const anims = groups.get(setId);
            if (!anims || anims.length === 0) continue;

            const key = setId || '_ungrouped';
            const isCollapsed = collapsedSets.has(key);

            if (setId) {
                const set = project.animationSets.find(s => s.id === setId);
                if (set) {
                    const header = document.createElement('div');
                    header.className = 'set-header' + (isCollapsed ? ' collapsed' : '');
                    header.innerHTML = `<span class="set-arrow">&#9660;</span><span class="set-name">${set.name}</span><span class="set-count">${anims.length}</span><span class="set-mirror-rule">${set.mirrorRule}</span><button class="set-remove" title="Remove set and its animations">X</button>`;
                    header.onclick = (e) => { if (!e.target.classList.contains('set-remove')) toggleSetCollapse(key); };
                    header.querySelector('.set-remove').onclick = (e) => { e.stopPropagation(); removeSetWithAnims(setId); };
                    container.appendChild(header);
                }
            } else if (project.animationSets.length > 0) {
                const header = document.createElement('div');
                header.className = 'set-header' + (isCollapsed ? ' collapsed' : '');
                header.innerHTML = `<span class="set-arrow">&#9660;</span><span class="set-name">Ungrouped</span><span class="set-count">${anims.length}</span>`;
                header.onclick = () => toggleSetCollapse(key);
                container.appendChild(header);
            }

            const body = document.createElement('div');
            body.className = 'set-body' + (isCollapsed ? ' collapsed' : '');
            for (const anim of anims) {
                buildAnimEntry(body, anim);
            }
            container.appendChild(body);
        }

        // Any sets not in setOrder (shouldn't happen, but safety)
        for (const [setId, anims] of groups) {
            if (setOrder.includes(setId)) continue;
            for (const anim of anims) buildAnimEntry(container, anim);
        }
    }

    function toggleSetCollapse(key) {
        if (collapsedSets.has(key)) collapsedSets.delete(key);
        else collapsedSets.add(key);
        buildLibraryUI();
    }

    function removeSetWithAnims(setId) {
        const set = project.animationSets.find(s => s.id === setId);
        const animCount = project.animationLibrary.filter(a => a.setId === setId).length;
        const name = set ? set.name : 'this set';
        if (!confirm(`Remove "${name}" and its ${animCount} animations?\n(Also removes any timeline blocks using them)`)) return;
        // Remove blocks referencing these animations
        const animIds = new Set(project.animationLibrary.filter(a => a.setId === setId).map(a => a.id));
        for (const g of project.groups) {
            g.blocks = g.blocks.filter(b => !animIds.has(b.animationId));
        }
        // Remove animations
        project.animationLibrary = project.animationLibrary.filter(a => a.setId !== setId);
        // Remove set
        project.animationSets = project.animationSets.filter(s => s.id !== setId);
        collapsedSets.delete(setId);
        buildLibraryUI();
        autoSave();
        renderTimeline();
    }

    function buildAnimEntry(container, anim) {
        const div = document.createElement('div');
        div.className = 'anim-entry';
        div.draggable = true;
        div.dataset.animId = anim.id;

        const mirrorName = getMirrorName(anim);
        const mirrorHtml = mirrorName ? `<div class="anim-mirror">Mirror: ${mirrorName}</div>` : '';

        div.innerHTML = `
            <div class="anim-actions">
                <button onclick="event.stopPropagation(); showEditAnimDialog('${anim.id}')">Edit</button>
                <button onclick="event.stopPropagation(); deleteAnimation('${anim.id}')">X</button>
            </div>
            <div class="anim-name">${anim.name}</div>
            <div class="anim-duration">${anim.duration.toFixed(1)}s${anim.markers.length ? ' | ' + anim.markers.length + ' markers' : ''}</div>
            ${mirrorHtml}
            <div class="anim-bar" style="background: ${anim.color};">
                ${anim.markers.map(m => `<div class="anim-marker-dot" style="left: ${(m.time / anim.duration * 100)}%;"></div>`).join('')}
            </div>
        `;

        div.addEventListener('dragstart', (e) => {
            dragFromLibrary = { animId: anim.id, ghostTrack: -1, ghostTime: 0 };
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', anim.id);
        });
        div.addEventListener('dragend', () => {
            dragFromLibrary = null;
            renderTimeline();
        });

        container.appendChild(div);
    }

    function showAddAnimDialog() {
        document.getElementById('animDialogTitle').textContent = 'Add Animation';
        document.getElementById('animDialogId').value = '';
        document.getElementById('animName').value = '';
        document.getElementById('animDuration').value = '8';
        document.getElementById('animColor').value = '#4488FF';
        document.getElementById('animMarkers').innerHTML = '';
        populateSetDropdown('');
        document.getElementById('mirrorPreview').textContent = '';
        document.getElementById('animDialog').classList.add('active');
    }

    function showEditAnimDialog(animId) {
        const anim = project.animationLibrary.find(a => a.id === animId);
        if (!anim) return;
        document.getElementById('animDialogTitle').textContent = 'Edit Animation';
        document.getElementById('animDialogId').value = anim.id;
        document.getElementById('animName').value = anim.name;
        document.getElementById('animDuration').value = anim.duration;
        document.getElementById('animColor').value = anim.color;
        const mkContainer = document.getElementById('animMarkers');
        mkContainer.innerHTML = '';
        for (const m of anim.markers) {
            addAnimMarkerRow(m.time, m.label);
        }
        populateSetDropdown(anim.setId || '');
        updateMirrorPreview();
        document.getElementById('animDialog').classList.add('active');
    }

    function addAnimMarkerRow(time, label) {
        const container = document.getElementById('animMarkers');
        const row = document.createElement('div');
        row.className = 'marker-row';
        row.innerHTML = `
            <input type="number" value="${time || 0}" step="0.1" min="0" placeholder="Time">
            <input type="text" value="${label || ''}" placeholder="Label">
            <button onclick="this.parentElement.remove()">X</button>
        `;
        container.appendChild(row);
    }

    function closeAnimDialog() {
        document.getElementById('animDialog').classList.remove('active');
    }

    function saveAnimation() {
        const id = document.getElementById('animDialogId').value;
        const name = document.getElementById('animName').value.trim();
        if (!name) { alert('Enter an animation name'); return; }
        const duration = parseFloat(document.getElementById('animDuration').value) || 1;
        const color = document.getElementById('animColor').value;
        const setId = document.getElementById('animSet').value;
        const markerRows = document.getElementById('animMarkers').querySelectorAll('.marker-row');
        const markers = [];
        markerRows.forEach(row => {
            const inputs = row.querySelectorAll('input');
            const t = parseFloat(inputs[0].value) || 0;
            const l = inputs[1].value.trim();
            if (l) markers.push({ time: t, label: l });
        });

        if (id) {
            // Edit existing
            const anim = project.animationLibrary.find(a => a.id === id);
            if (anim) {
                anim.name = name;
                anim.duration = duration;
                anim.color = color;
                anim.markers = markers;
                anim.setId = setId;
            }
        } else {
            // Add new
            project.animationLibrary.push({
                id: generateId('anim'),
                name, duration, color, markers, setId
            });
        }

        closeAnimDialog();
        buildLibraryUI();
        autoSave();
        renderTimeline();
    }

    function deleteAnimation(animId) {
        // Check if used on timeline
        let used = false;
        for (const g of project.groups) {
            if (g.blocks.some(b => b.animationId === animId)) { used = true; break; }
        }
        const msg = used ? 'This animation is used on the timeline. Delete it anyway?' : 'Delete this animation?';
        if (!confirm(msg)) return;

        project.animationLibrary = project.animationLibrary.filter(a => a.id !== animId);
        // Remove blocks referencing it
        for (const g of project.groups) {
            g.blocks = g.blocks.filter(b => b.animationId !== animId);
        }
        buildLibraryUI();
        autoSave();
        renderTimeline();
    }

    // ===== ANIMATION SETS =====
    function getMirrorName(anim) {
        if (!anim.setId) return '';
        const set = project.animationSets.find(s => s.id === anim.setId);
        if (!set || !set.mirrorRule) return '';
        return set.mirrorRule.replace(/\{name\}/g, anim.name);
    }

    function showSetsDialog() {
        buildSetsListUI();
        document.getElementById('setsDialog').classList.add('active');
    }

    function closeSetsDialog() {
        document.getElementById('setsDialog').classList.remove('active');
        buildLibraryUI();
        renderTimeline();
    }

    function buildSetsListUI() {
        const container = document.getElementById('sets-list');
        container.innerHTML = '';
        for (const s of project.animationSets) {
            const animCount = project.animationLibrary.filter(a => a.setId === s.id).length;
            const div = document.createElement('div');
            div.className = 'sets-list-item';
            div.innerHTML = `
                <span class="set-item-name">${s.name}</span>
                <span class="set-item-rule">${s.mirrorRule} (${animCount} anims)</span>
                <button onclick="editSet('${s.id}')">Edit</button>
                <button onclick="deleteSet('${s.id}')" style="background: #633;">X</button>
            `;
            container.appendChild(div);
        }
        if (project.animationSets.length === 0) {
            container.innerHTML = '<div style="color: #666; font-size: 11px; padding: 8px;">No sets defined. Add one below.</div>';
        }
    }

    function addSet() {
        const name = document.getElementById('newSetName').value.trim();
        const rule = document.getElementById('newSetRule').value.trim();
        if (!name) { alert('Enter a set name'); return; }
        if (!rule || !rule.includes('{name}')) { alert('Mirror rule must contain {name} placeholder'); return; }
        project.animationSets.push({
            id: generateId('set'),
            name: name,
            mirrorRule: rule
        });
        document.getElementById('newSetName').value = '';
        document.getElementById('newSetRule').value = '{name}_mirror';
        buildSetsListUI();
        autoSave();
    }

    function editSet(setId) {
        const s = project.animationSets.find(x => x.id === setId);
        if (!s) return;
        const newName = prompt('Set name:', s.name);
        if (newName === null) return;
        const newRule = prompt('Mirror rule (use {name} for animation name):', s.mirrorRule);
        if (newRule === null) return;
        if (!newRule.includes('{name}')) { alert('Mirror rule must contain {name} placeholder'); return; }
        s.name = newName.trim() || s.name;
        s.mirrorRule = newRule.trim();
        buildSetsListUI();
        autoSave();
    }

    function deleteSet(setId) {
        const animCount = project.animationLibrary.filter(a => a.setId === setId).length;
        const msg = animCount > 0 ? `This set has ${animCount} animations. Unassign them and delete?` : 'Delete this set?';
        if (!confirm(msg)) return;
        project.animationSets = project.animationSets.filter(s => s.id !== setId);
        for (const a of project.animationLibrary) {
            if (a.setId === setId) a.setId = '';
        }
        buildSetsListUI();
        autoSave();
    }

    function populateSetDropdown(selectedId) {
        const sel = document.getElementById('animSet');
        sel.innerHTML = '<option value="">(none)</option>';
        for (const s of project.animationSets) {
            const opt = document.createElement('option');
            opt.value = s.id;
            opt.textContent = s.name;
            if (s.id === selectedId) opt.selected = true;
            sel.appendChild(opt);
        }
    }

    function updateMirrorPreview() {
        const name = document.getElementById('animName').value.trim();
        const setId = document.getElementById('animSet').value;
        const preview = document.getElementById('mirrorPreview');
        if (!name || !setId) { preview.textContent = ''; return; }
        const set = project.animationSets.find(s => s.id === setId);
        if (!set) { preview.textContent = ''; return; }
        const mirrorName = set.mirrorRule.replace(/\{name\}/g, name);
        preview.textContent = 'Mirror: ' + mirrorName;
    }

    // ===== MARKER DIALOG =====
    function showMarkerDialog(markerId, defaultTime) {
        if (markerId) {
            const m = project.markers.find(x => x.id === markerId);
            if (!m) return;
            document.getElementById('markerDialogTitle').textContent = 'Edit Marker';
            document.getElementById('markerDialogId').value = m.id;
            document.getElementById('markerLabel').value = m.label;
            document.getElementById('markerTime').value = m.time;
            document.getElementById('markerColor').value = m.color;
        } else {
            document.getElementById('markerDialogTitle').textContent = 'Add Section Marker';
            document.getElementById('markerDialogId').value = '';
            document.getElementById('markerLabel').value = '';
            document.getElementById('markerTime').value = defaultTime || 0;
            document.getElementById('markerColor').value = '#FF6644';
        }
        document.getElementById('markerDialog').classList.add('active');
    }

    function closeMarkerDialog() { document.getElementById('markerDialog').classList.remove('active'); }

    function saveMarker() {
        const id = document.getElementById('markerDialogId').value;
        const label = document.getElementById('markerLabel').value.trim();
        if (!label) { alert('Enter a label'); return; }
        const time = parseFloat(document.getElementById('markerTime').value) || 0;
        const color = document.getElementById('markerColor').value;

        if (id) {
            const m = project.markers.find(x => x.id === id);
            if (m) { m.label = label; m.time = time; m.color = color; }
        } else {
            project.markers.push({ id: generateId('mkr'), time, label, color });
        }
        closeMarkerDialog();
        autoSave();
        renderTimeline();
    }

    // ===== LYRIC DIALOG =====
    function showLyricDialog(lyricId, defaultTime) {
        if (lyricId) {
            const l = project.lyrics.find(x => x.id === lyricId);
            if (!l) return;
            document.getElementById('lyricDialogTitle').textContent = 'Edit Lyric';
            document.getElementById('lyricDialogId').value = l.id;
            document.getElementById('lyricText').value = l.text;
            document.getElementById('lyricTime').value = l.time;
        } else {
            document.getElementById('lyricDialogTitle').textContent = 'Add Lyric';
            document.getElementById('lyricDialogId').value = '';
            document.getElementById('lyricText').value = '';
            document.getElementById('lyricTime').value = defaultTime || 0;
        }
        document.getElementById('lyricDialog').classList.add('active');
    }

    function closeLyricDialog() { document.getElementById('lyricDialog').classList.remove('active'); }

    function saveLyric() {
        const id = document.getElementById('lyricDialogId').value;
        const text = document.getElementById('lyricText').value.trim();
        if (!text) { alert('Enter lyric text'); return; }
        const time = parseFloat(document.getElementById('lyricTime').value) || 0;

        if (id) {
            const l = project.lyrics.find(x => x.id === id);
            if (l) { l.text = text; l.time = time; }
        } else {
            project.lyrics.push({ id: generateId('lyr'), time, text });
        }
        closeLyricDialog();
        autoSave();
        renderTimeline();
    }

    // ===== CONTEXT MENU =====
    function showContextMenu(clientX, clientY, items) {
        const menu = document.getElementById('context-menu');
        menu.innerHTML = '';
        for (const item of items) {
            const div = document.createElement('div');
            div.className = 'ctx-item';
            div.textContent = item.label;
            div.onclick = () => { hideContextMenu(); item.action(); };
            menu.appendChild(div);
        }
        menu.style.left = clientX + 'px';
        menu.style.top = clientY + 'px';
        menu.classList.add('active');
    }

    function hideContextMenu() {
        document.getElementById('context-menu').classList.remove('active');
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#context-menu')) hideContextMenu();
    });

    // ===== PERSISTENCE =====
    function getProjectState() {
        project.viewState.scrollX = scrollX;
        project.viewState.snapToGrid = document.getElementById('snapToggle').checked;
        return JSON.parse(JSON.stringify(project));
    }

    function migrateProject(state) {
        if (!state.version || state.version < 2) {
            // v1 â†’ v2: add animationSets, setId per animation, mirrored per block
            state.animationSets = state.animationSets || [];
            for (const a of (state.animationLibrary || [])) {
                if (a.setId === undefined) a.setId = '';
            }
            for (const g of (state.groups || [])) {
                for (const b of (g.blocks || [])) {
                    if (b.mirrored === undefined) b.mirrored = false;
                }
            }
            state.version = 2;
        }
        return state;
    }

    function setProjectState(state) {
        project = migrateProject(state);
        scrollX = state.viewState ? state.viewState.scrollX || 0 : 0;
        document.getElementById('songTitle').value = project.song.title;
        document.getElementById('songDuration').value = formatTime(project.song.duration);
        document.getElementById('songBPM').value = project.song.bpm || 0;
        document.getElementById('snapToggle').checked = project.viewState ? project.viewState.snapToGrid : false;
    }

    function autoSave() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(getProjectState()));
        } catch (e) { console.warn('Auto-save failed:', e); }
    }

    function loadFromStorage() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) { setProjectState(JSON.parse(saved)); return true; }
        } catch (e) { console.warn('Load failed:', e); }
        return false;
    }

    function exportProject() {
        const json = JSON.stringify(getProjectState(), null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'timeline-project-' + new Date().toISOString().slice(0, 10) + '.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function importProject(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                setProjectState(JSON.parse(e.target.result));
                buildLibraryUI();
                autoSave();
                renderTimeline();
                alert('Project imported!');
            } catch (err) { alert('Import failed: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function newProject() {
        if (!confirm('Start a new timeline project? This clears all current data.')) return;
        localStorage.removeItem(STORAGE_KEY);
        project = createDefaultProject();
        setProjectState(project);
        interaction = { dragging: null, hovering: null, selectedBlock: null, selectedGroup: null };
        playback = { playing: false, cursorTime: 0, startTs: null };
        buildLibraryUI();
        updateTimeDisplay();
        renderTimeline();
    }

    function exportLibrary() {
        const json = JSON.stringify(project.animationLibrary, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'animation-library-' + new Date().toISOString().slice(0, 10) + '.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function importLibrary(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const lib = JSON.parse(e.target.result);
                if (Array.isArray(lib)) {
                    // Merge: add animations that don't exist by name
                    for (const a of lib) {
                        if (!project.animationLibrary.find(x => x.name === a.name)) {
                            a.id = generateId('anim');
                            project.animationLibrary.push(a);
                        }
                    }
                    buildLibraryUI();
                    autoSave();
                    alert('Library imported! (' + lib.length + ' animations)');
                }
            } catch (err) { alert('Import failed: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function importCSV(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const text = e.target.result;
                const lines = text.split(/\r?\n/);
                let currentSetId = '';
                let setsCreated = 0;
                let animsCreated = 0;
                let animsSkipped = 0;
                const colors = ['#4488FF', '#FF4488', '#44FF88', '#FF8844', '#8844FF', '#44FFFF', '#FF44FF', '#88FF44', '#FFFF44', '#FF6666', '#6666FF', '#66FF66'];
                let colorIdx = project.animationLibrary.length;

                for (const rawLine of lines) {
                    const line = rawLine.trim();
                    if (!line || line === ',') continue;

                    const commaIdx = line.lastIndexOf(',');
                    if (commaIdx < 0) continue;

                    const name = line.substring(0, commaIdx).trim();
                    const durStr = line.substring(commaIdx + 1).trim();
                    const duration = parseFloat(durStr);

                    if (!name) continue;

                    if (!duration || duration <= 0) {
                        // Set header line: name with no valid duration
                        const existing = project.animationSets.find(s => s.name.toLowerCase() === name.toLowerCase());
                        if (existing) {
                            currentSetId = existing.id;
                        } else {
                            const newSet = { id: generateId('set'), name: name, mirrorRule: '{name}_mirror' };
                            project.animationSets.push(newSet);
                            currentSetId = newSet.id;
                            setsCreated++;
                        }
                    } else {
                        // Animation line
                        if (project.animationLibrary.find(a => a.name === name)) {
                            animsSkipped++;
                            continue;
                        }
                        project.animationLibrary.push({
                            id: generateId('anim'),
                            name: name,
                            duration: duration,
                            color: colors[colorIdx % colors.length],
                            markers: [],
                            setId: currentSetId
                        });
                        colorIdx++;
                        animsCreated++;
                    }
                }

                buildLibraryUI();
                autoSave();
                renderTimeline();
                alert(`CSV imported!\n${animsCreated} animations added, ${setsCreated} sets created` +
                    (animsSkipped > 0 ? `, ${animsSkipped} duplicates skipped` : ''));
            } catch (err) { alert('CSV import failed: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    // ===== CANVAS SIZING =====
    function resizeCanvas() {
        const container = document.getElementById('canvas-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        renderTimeline();
    }

    // ===== INIT =====
    function init() {
        if (!loadFromStorage()) {
            project = createDefaultProject();
            setProjectState(project);
        }
        resizeCanvas();
        buildLibraryUI();
        updateTimeDisplay();
        renderTimeline();
    }

    window.addEventListener('resize', resizeCanvas);
    init();
</script>
</body>
</html>
